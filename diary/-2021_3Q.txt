[ EntityComponentSystem ]、、、、、、、、、、、、、作業中
・調査
　→Entity Component System概要
　　https://youtu.be/04NJNA8ypw0?t=250

　→実装例
　　https://austinmorlan.com/posts/entity_component_system/

・プロトタイピング、、、、、、、作業中





[ HTTP通信クラス実装 ]、、、、、、、、、、、、、、、、作業中




[ Timerクラス実装 ]、、、、、、、、済



[ Memory::Shrink/Extend使ってる機能の動作チェック ]、、、、、、、済
・PriorityQueue動作確認、、、、、、、、、、、済
　→ついでにSizeTypeまわりも修正中

・RingQueue動作確認、、、、、、、、、、、、、済
　→ついでにSizeTypeまわりも修正中



[ Memory::Reize関数リファクタリング ]、、、、、、、、、、、、、済
・Resize関数：使い方が3種類の調査、、、、、、、、、、、、、済
　→必要最低限のコンストラクタ呼び出しだけで初期化必要ない場合
　　→ReallocateBuffer
　→新規作成要素は全てコンストラクタで初期化済みにしてほしい場合
　　→ReallocateBuffer + new (iter) T()
　→新規作成要素を全て指定データfillで埋めてほしい場合
　　→ReallocateBuffer + new (iter) T(fill)
・ReallocateBuffer関数の実装、、、、、、、、、、、、、、、済
　→





gitディレクトリが既にあるかどうか確認したい
https://stackoverflow.com/questions/39518124/check-if-directory-is-git-repository-without-having-to-cd-into-it

git -C <path> rev-parse

GridSearch
→DesignParams












//================ Other =================//
・Varidic template

・そろそろOreOreLibを独立したリポジトリに、、、、、、、、、、、済
　→BitArrayはcontainerへ移動
　→OreOreLibモジュール依存関係
　　::common........... -
　　::meta....................common
　　::thread.................common
　　::mathlib..............common
　　::os.........................common, mathlib
　　::memory.............common, meta, mathlib, os
　　::network.............common, memory, meta
　　::container...........common, memory, meta, mathlib
　　::matrixlib............common, meta, memory, mathlib, container




・BitArray〜文字列の変換ロジックを作る、、、、、、、、、、、、作業中
　→仕様検討
　　→"01010011"の文字列にする？
　　→unsigned char型のバイト列？
　→tstring経由でインポート/エクスポートする機能を追加、、、済
　→CSVファイル読み書き挟んでも再現性あるか確認する、、、、、作業中
　　→EALibで試す


・どんな変数型でも代入可能なVariant型の実装、、、、、、、、、済
　→スマートポインタでも対応可
　→メモリリーク対策済み



・自作コンテナ機能拡張、、、、、、、、、、、、、、、、、、、、、済
　→Arrayコンストラクタの初期化子対応

https://stackoverflow.com/questions/5549524/how-do-i-initialize-a-member-array-with-an-initializer-list/5549918#5549918
　→HashMapコンストラクタの初期化子対応、、、、済


・HashMap機能拡張：ハッシュ関数、、、、、、、済
　https://bestofcpp.com/repo/greg7mdp-sparsepp-cpp-containers

・HashMapを自作する、、、、、、、済
→https://aozturk.medium.com/simple-hash-map-hash-table-implementation-in-c-931965904250

・HashMpa機能追加、、、、、、済
→Empty、、、、、済
→Length、、、、済
→Exists、、、、、、済



[ MemoryAllocator(BoundaryTag使ってるやつ)に機能改善 ]、、、、、、中止
　→Allocate( size_t size, size_t alignment )//アラインメントできるようにする試作、、済
　　→ヘッダーはアラインメントなし
　　→データ開始位置だけアラインメントをかける
　　→ヘッダー〜データ開始位置間に可変長の隙間ができる
　　→Deallocateでデータ開始位置のポインタ受け取っても削除できない
　　→データ開始位置直前に、ヘッダー開始位置へのオフセットorアドレスを埋め込む
　→優先度低いため中止する


[ Arrayの多次元配列対応 ]、、、、、、、、、済
　→それともstring型の要素確保がまずい？ -> 近いs、、、、、済
　　→string型でmemcpyがまずい→std::copyに置き換えた
　　→クラスインスタンスの時点でmemcpyまずい? -> is_trivially_copy_assignable<T>::value がtrueなら大丈夫
　　　→参考記事: https://stackoverflow.com/questions/30386622/using-memcpy-to-copy-an-array-of-objects



[ OreOreLib機能拡張 ]、、、、、、、、、作業中
　→CudaCaffeViewportCmdのVectorMath.hを追加登録する
　→algorithm/distance.hに置いてあるけどリファクタリング必要



[ TypeList使って特殊化した実装を自動宣言 ]、、、、保留
https://stackoverflow.com/questions/32444256/can-i-declare-a-template-specialization-from-a-typelist/33084314



[ 型情報から変数へ変換する方法 ]、、、、、、、、、、、済

[ BitArrayクラス実装 ]、、、、、、、、、、、、、、、、、、、、済
　→EALibのBinaryStringをOreOreLibへ移動



//================= EALib ================//


//================= CUDA ==================//




//====== Maya上で画像データ貼り付けて回転させてみる ======//
・Maya プラグインにLibtorch組み込む
　→学習済みモデルVGG19で動作確認する
　　→torchvisionからダウンロードして、pytorch上で特徴ベクトル取得できるようにする
　→コマンドラインからmaya起動する方法をきく、、、、、済


・フレームバッファ画像から解像度整形するCUDAカーネル
　→長軸で切り取って正方形にする
　→



[ LibTorch : Tensorをリサイズできるか試してみる ]
https://runebook.dev/ja/docs/pytorch/generated/torch.nn.zeropad2d



[ Libtorch : CudaMemoryで直接tensor初期化してみる ]、、、、済



[ Libtorch : PyTorchのモデルをLibTorchで動かしてみる ]、、、、済
・CNN_MNIST持ってってみる
　　https://pytorch.org/tutorials/advanced/cpp_export.html
　
・中間層の出力を取得する、、、、、、、、、、、、、、、済
・途中の層まで計算する、、、、、、、、、、中止







[ PyTorch : Tensorのリサイズ ]、、、、、、、、、作業中
https://discuss.pytorch.org/t/libtorch-resize-function/45203/2

downsample
interpolate


[ PyTorch : 中間層の出力を取得する ]、、、、、済
→register_forward_hook使って実装？ TorchScriptだと無理
https://discuss.pytorch.org/t/how-can-l-load-my-best-model-as-a-feature-extractor-evaluator/17254/6

→nn.Sequential使って構造すげ替え、、、うまくいかない。なんで？
https://medium.com/the-owl/extracting-features-from-an-intermediate-layer-of-a-pretrained-model-in-pytorch-c00589bda32b

https://forums.fast.ai/t/pytorch-best-way-to-get-at-intermediate-layers-in-vgg-and-resnet/5707/3

https://stackoverflow.com/questions/46513886/how-to-get-ouput-from-a-particular-layer-from-pretrained-cnn-in-pytorch

　→forwardでカスタム処理書いた場合に、演算順序を拾えない

→対策：
　→Sequential使って、順序決め打ちできる処理群をまとめておく
　　→特徴量の抽, etc...
　→register_forward_hookも手段としてはあるが、、、
　　→ScriptModule未対応 & 横に処理挟むだけ
　→

→model.children()で中間層捕まえられるのは、nn.Sequential使ってレイヤー実行順序を予め決めてある場合のみ。forwardで任意の順序で処理組んだ場合はムリ

→


・[ ResNet/ResNet50 の実装 ]
https://nuka137.hatenablog.com/entry/2020/09/24/162417

・[ torchvisionセットアップ ]、、、、済


・[ モデルのGPU対応 ]、、、、、、済

・ モデル作る ] 、、、、、、、、、、、、、済
→MNIST_多層パーセプトロン、、、、済
→MNIST_CNN、、、、、、、、、、、、済
　→chainer版を移植してトレーニングまで完了
　→推論テスト：
　　→jit::script：完了
　　→jit::trace：完了

・accuracyとlossを表示する ]、、、、、済
　→epoch毎にLossを表示、、、済
　→epoch毎にAccuracyを表示、、、、済

・モデルをファイル保存 ]、、、、、済
　→ファイルに保存する、、、、、、、済
　→読み込んで推論する、、、、、、済
　→torch.jit.traceで試してみる、、、、、、、済
https://tech-blog.optim.co.jp/entry/2020/08/17/090000
　→torch.jit.script、、、、、、、、、、、、、、済
　　→forwardに追加引数くっつけたりするとアウト
https://runebook.dev/ja/docs/pytorch/generated/torch.jit.save



https://github.com/szagoruyko/pytorchviz







[ MemoryAllocator : クラス整理 ]、、、、、、、、、、、、未着手
・コピーコンストラクタ
・ムーブコンストラクタ
・Move Assignment Operator


[ MemoryAllocator : アラインメント調整する ]、、、、、、、、、、、、、、、済
　→struct型の配列を確保して、値が正しく代入できるか試す、、、済
　　→x86プロセッサだからできるけど、アドレス境界跨いでる

　→UE4の実装を調査 ( BinnedAlocator )、、、、、、、、、、、、、済
　　→8バイトのデフォルトアラインメントでメモリ空間は準備してある
　　　→8バイト = sizeof(FFreeMem)
　　→8バイト以上のAlignmentが指定された場合は、、、
　　　→アラインメント可能になるよう、確保するメモリサイズを広げる
　　　→アラインメントされた先頭アドレスから領域を確保して返す
　　→FMallocBinned::Malloc( SIZE_T Size, uint32 Alignment )
　　　→アライメントを引数指定できるようになってる

・アライメント調整の仕様決め：2段階で実施する、、、、、、、、、、、、、、、、、、、済
　→デフォルトの8バイトアラインメントを実装する、、、、、、、、、済
　　→PoolAllocatorのメモリ開始位置を8バイトに揃える、、、済
　　　→RegionTagは40バイトだからそのままでOK
　　　→PageTag(m_PageTagSize)を8バイト切り上げ
　　　→ブロックサイズは8バイト単位なので大丈夫なハズ
　　→ブロックサイズ変更して動作テスト、、、、、、、、、、、、、済
　→カスタムアラインメントを実装する、、、、、、、、、、、、、、、済
　　→MemoryManagerのAllocateで実装する
　　　→void* Allocate( size_t size, size_t alignment );
　　　→サイズとアライメントから必要メモリ容量を算出する
　　　→該当するプールからメモリを取得する
　　　→アライメントをかけたアドレスを返す


　→参考資料
　　https://www.gamedev.net/articles/programming/general-and-gameplay-programming/c-custom-memory-allocation-r3010/
　　https://zhuanlan.zhihu.com/p/75826986



[ MemoryAllocator : 未使用仮想メモリをOSに返す方法ある？ ]、、、、、済
　→PoolAllocatorに追加実装必要
　　→m_FeedNilでリスト化
　→Cleanup
　　→m_FeedNilからAllocationBase取得
　　→m_Dirtyまでのページを探索
　→使用中/未使用VM混在状態でテスト完了


[ MemoryAllocator : メモリ未使用領域を減らしたい ]、、、、、、、、、済
　→3割以上未使用のPoolAllocator発生
　　→例：98304KB確保、ブロックサイズ32768：3K近く無駄になる
　→対策
　　→案1: m_BlockSize整数倍確保できるよう、m_AllocSizeを切り上げ/切り捨てる
　　→案2: m_AllocSizeの代わりにブロック数を指定する
　　→案3: m_AllocSizeの自動計算ロジックを実装する
　　→案4: m_AllocSizeのラインナップを最適化する

　→4kbページサイズ以上のムダが出ている場合は？
　　→ページサイズでアライメントかける


[ MemoryAllocator : MemoryManager::Allocate/Freeの実装 ]
　→Allocate、、、、、、、、、、、、、、、、、、、、済
　　→32768バイト以上の領域確保対策
　　　→OSAllocator使って直接アロケートする
　　　→LargeMemory専用のRegionTagを先頭に仕込んでおく
　→Free、、、、、、、、、、、、、、、、、、、、、、、済
　　→ベースアドレスに
　→Reallocate、、、、、、、、、、、、、、、、、、、済
　→Callocate、、、、、、、、、、、、、、、、、、、、未着手



[ MemoryAllocator : mimalloc分析 ]
→_mi_segment_page_start
→MI_PAGE_SMALLの(64kb以下)ページの場合
　→segment_infoはblocksizeで切り上げた領域に配置。ページ開始位置をアライメント
　→ページごとの物理メモリコミットで4kb境界気にする必要ある
　
→それ以外(64kbより大きい)ページの場合
　→セグメント内にページが1個だけのケースではブロックアライメントなし
　→ページ1個分一気に物理メモリ確保済み
　→バイト列の切り出し：ブロック単位でのアライメント気にしない

→Pageは64KiB、Blockは4KiB





[DLLとSTLの相性が悪い理由]
http://nwhite.s19.xrea.com/mt/archives/2004/11/dllstl.html






[ 標準出力をマルチスレッドQTextEditで拾って表示 ]
・Worker(QObject)で実装が必要
　→標準出力をポーリングするため
・stdoutだけ切り離して非同期化するのはムリ
・stdoutした後でQTextEditに出力する部分が重い。ここを非同期処理に置き換える
　→sys.stdout.writeの代替関数？
・TODO:
　→キューにメッセージを貯める
　→QThread使ったワーカーの実装も必要か（毎回スレッド生成は重すぎ。）
・参考記事
　https://stackoverflow.com/questions/21071448/redirecting-stdout-and-stderr-to-a-pyqt4-qtextedit-from-a-secondary-thread
